const log = console.log;

/* Почему при сложении двух float значений у нас может теряется точность? 
В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления. 
Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. Из за этого возникают такие числа.
https://learn.javascript.ru/number#netochnye-vychisleniya */
// log(0.1 + 0.2);
// log(`Исправление: ${+(0.1 + 0.2).toFixed(2)}`);
// log(9999999999999999);
// log(`Исправление: ${9999999999999999n}`);

/* Для чего используется оператор "&&", "||", "!", "!!"?
Для начала стоит понимать что будет вычислятся первым в таблице приоритетности. 
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
Так же стоит знать что такое Truthy и Falsy
https://developer.mozilla.org/en-US/docs/Glossary/Truthy
https://developer.mozilla.org/en-US/docs/Glossary/Falsy
&& - сравнивает операнды слева направо и если оба они = true, тогда возвратит последний операнд. Когда один из операндов = false - оператор возвратит этот операнд.
|| = сравнивает операнды слева направо и если какой нибудь из них имеет значение true - этот операнд и возвращается. Когда оба операнда = false - оператор возвратит последний операнд
! = оператор отрицания или еще называют логичеким NOT - возвращает Boolean в случае, если ! был применен на Boolean, в другом случае js попытает преобразовать значение справа от ! в Boolean и 'перверенет' его на противоположное.
!! = оператор двойного отрицания принудительно приводит значение к boolean primitive
*/
// &&
// log(0 && -1) //2ое правило &&
// log('true' && 'false') // строки считаются как t
// log('' && 'true') // пустая строка считается как f
// let a = true && 0 + 1; // + имеет больший приоритет, поэтому выполняется сначала вывод его выражения, а уже потом вывод оператора &&
// log(a);
// ||
// log(0 || 1) один из операндов == true и выводится именно он
// log('string' || false) один из операндов == true и выводится именно он
// log('' || 0) // оба оператора == f; 0 -2ое правило ||
// let a = false || 55; // один из операндов == true и выводится именно он
// log(a) // 55
//!
// log(!true) // True переводится в false
// log(!'') // Пустая строка false , переводится в true
// log(!'false') // заполненная строка в любом случае считается как t и переводится  в false
// log(![]) // Пустой массив true, переводится в false
//!!
// log(!!true) // true -> false -> true
// log(!!0) // false -> true -> false
// log(!!'false') // true -> false -> true
// log(!!{}) // true -> false -> true

/* Как ты понимаешь, что такое this?
Свойство контекста выполнения кода (global, function или eval), которое в нестрогом режиме всегда является ссылкой на объект, а в строгом режиме может иметь любое значение.
В глобальном контексте выполнения (за пределами каких-либо функций) this ссылается на глобальный объект вне зависимости от режима (строгий или нестрогий).
В пределах функции значение this зависит от того, каким образом вызвана функция. Имеется ввиду что есть разница между тем как вызывать фцию внутри которой this, используется ли обычный вызов, так и вызовы с методами apply, call, bind (О них можно прочитать ниже).
В пределах объекта значение this выставляется из ближайшего родительского объекта метода, который вызывается.
В стрелочных функциях, this привязан к окружению, в котором была создана функция.

https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D1%82%D0%BE%D0%BC-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-this-%D0%B2-javascript-a13b4b6ec9ac
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this
*/
//global
// log(this) // ссылается на window
// //function
// function thisIs() {
//   log(`this является: ${this}`)
// }
// thisIs() //вызов фции происходит без какой либо привязки
//Object
// let obj = {
//   name: 'Ivan',
//   surname: 'DarkHolmie',
//   age: 20,
//   callThis: function() {
//     log(`this является: ${this}`);
//   },
//   callMyName: function() {
//     log(`this.name является: ${this.name}`);
//   }
// }
// thisIs.call(obj) // с привязкой выводит this - Object
// obj.callThis() // вызов метода с this без привязки, ссылается на Object, который вызвал этот метод
// obj.callMyName() // так же мы из вызвавшего объекта вытаскиваем pyfxtybt свойствf name
// 2ой пример 2 объекта
// let programmers = {
//   name: 'Ivan',
//   sex: 'Dangeon Master', // *
//   nickname: function() {
//     return this.sex
//   },
//   otherIvan: {
//     sex: 'Cumshoter', // *
//     nickname: function() {
//       return this.sex
//     }
//   }
// }
// log(programmers.nickname())
// log(programmers.otherIvan.nickname()) // здесь мы видим цепочку из вызова объекта как свойства другого объекта, this следует правилу и привязывается к ближайшему объекту (otherIvan), а не к тому который изначально его вызывал (programmers).
//Object особенности new и class
// Когда используется new, this привязывается к новому объекту, который только что был создан
// class Me {
//   constructor(name, surname) {
//     this.name = name;
//     this.surname = surname;
//   }

//   callme() {
//     return `My name is ${this.name}, surname is ${this.surname}`;
//   }
// }
// let profileObj = {
//   name: 'Ivan',
//   surname: 'Dangeon Master'
// }
// log(new Me().callme.call(profileObj)); //вызов метода с помощью call - примязка свойств нашего объекта
// let me = new Me('Ivan', 'Dick300'); // создание нового объекта и вызов его уже с переданными как аргуметы значеними
// log(me.callme())
// Стрелочные фции
// let obj = { bar : function() {
//               let x = (() => this);
//               return x;
//             }
//           };
// let something = obj.bar() //Присваиваем ссылку возвращаемой функции переменной something
// log(something() === obj) // вызываем стрелочную функцию без определения this, срелочная фция понимает на каком объекте она была заскнута (obj), при использовании обычной фции в таком же контексте - мы бы получали window

/* Что такое apply, call, bind? В чем состоит разница между ними?
В JavaScript функции это объекты. И как объекты, функции имеют свои методы,как apply(), call() и bind(). 
Можно сказать, что Apply() и Call() буквально идентичны друг другу и зачастую используются в JavaScript для того, чтобы заимствовать методы и выставлять значения this.
В общем.
// call() --- /
// Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами.

// Синтаксис
// fun.call(thisArg[, arg1[, arg2[, ...]]])

// Пример с объектом:
// let person = { // Создаем объект к которому мы будет использовать call()
//   name: 'Ivan', // Имя
//   age: 96, // Возраст
//   personInfo() { // Информация
//     log(`Этого человека зовут ${this.name}. Его возраст составляет ${this.age}`)
//   },
// }

// let person2 = { // Создаем объект , который мы будем использовать как 'this'
//   name: 'Vanya', // Имя
//   age: 30 // Возраст
// }

// person.personInfo.call(person2) // Используем наш объект person2 , как this в методе personInfo объекта person. Без написания какого любого объекта в методе call , this.name == und и this.age == und , то есть this не будет ссылаться на какой-то объект.

// Пример с классом и объектом:

// class Animal { // Создаем класс к которому мы будет использовать call()
//   constructor(name,volume) { // Конструктор принимает переданные аргументы и укомплектовывает их
//     this.name = name; // name == первому переданному аргументу
//     this.volume = volume // volume == второму переданному аргументу
//   }
//   getInfo(food,age) { // Создаем метод, в котором используется аргументы , выступающие , как св-ва
//     this.food = food // Добавляем дополнительные св-ва переданные , как аргумент в вызове данного метода
//     this.age = age // 
//     log(`Это животное  ${this.name}. Ему ${this.age} лет. Громкость которого ${this.volume} дцб. Питается   //      чаще всего ${this.food}`)
//   }
// }

// let lion = { //  Создаем объекты, которые будут использоваться , как this в методе getInfo() класса Animal
//   name: 'Лев',
//   volume: '0.9'
// }

// let tiger = {
//   name: 'Тигр',
//   volume: '0.7'
// }
/* new Animal().getInfo.call(lion, 'Мясом', '19') // Создаем новый объект и привязываем с помощью call() объект lion, теперь lion выступает за роль this , а так-же добавляем 2 аргумента в метод getInfo() 
this.food == "Мясом", this.age == 19. 
Получаем: Это животное Лев. Ему 19 лет. Громкость которого 0.9 дцб. Питается чаще всего Мясом.
*/
// new Animal().getInfo.call(tiger, 'Мясом', '10')
// Получаем: Это животное Тигр. Ему 10 лет. Громкость которого 0.7 дцб. Питается чаще всего Мясом.

// apply() --- /
// Метод apply() полностью идентичен функции call(), но принимает в себя массив, как аргумент

// Синтаксис
// fun.apply(thisArg, [argsArray])

// Пример с классом и объектом

// class Animal { 
//   constructor(name,volume) { 
//     this.name = name; 
//     this.volume = volume 
//   }
//   getInfo(food,age) { 
//     this.food = food 
//     this.age = age 
//     log(`Это животное  ${this.name}. Ему ${this.age} лет. Громкость которого ${this.volume} дцб.   Питается  чаще всего ${this.food}`)
//   }
// }

// let arr = ['Мясом', 19]

// let lion = {
//   name: 'Лев',
//   volume: '0.9'
// }

// let tiger = {
//   name: 'Тигр',
//   volume: '0.7'
// }


// new Animal().getInfo.apply(lion, arr) // Как мы видим, вся процедура такая-же , как и call(), только в аргументы передаем массив, а в call() через запятую
// new Animal().getInfo.apply(tiger, ['Мясом', 10])

// bind() --- /
// Метод bind() Cоздаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение.
//
// Синтаксис
// fun.bind(thisArg[, arg1[, arg2[, ...]]])
//
//Пример с классом и объектом
//

// let date = new Date(); // создаем переменную которая будет являтся ссылкой на объект Date

// class Person  {
//   constructor(name,yearBirth) {
//     this.name = name,
//     this.yearBirth = yearBirth
//   }
  // calculateAge() {
  //   log(`${this.name}, ${date.getFullYear() - this.yearBirth} год`)
  // }
// }

// let obj = {
//   name: 'Egor',
//   yearBirth: 1990,
// }

// new Person().calculateAge.bind(obj)() //  Привязываем к методы класса Person объект obj , как this
//Результат : Egor , 31 год
//Пример с объектом // создаем переменную которая будет являтся ссылкой на объект Date
//
// let date = new Date();
// let person = {
//   name: 'Egor',
//   yearBirth: 1985,
//   calculateAge(job) {
//     log(`${this.name}, ${date.getFullYear() - this.yearBirth} год. Работает на ${job}`)
//   }
// }

// let person2 = {
//   name: 'Vlad',
//   yearBirth: 1930,
// }

// person.calculateAge.bind(person2, 'Стройке')()
// Привязываем к методы объекта person объект person2 , как this
//Результат : Vlad , 91 год


// Итог: bind,call,aplly мы используем для привязки объекта , как this в методаъ объектов, классов и функкий конструкторов


// Какая разница между ключевыми словами «var», «let» и «const»?
/*  let и const ведут себя одинаково по отношению к лексическому окружению, области видимости. 
Для «var» не существует блочной области видимости. «var» обрабатываются в начале запуска функции - Это поведение называется «hoisting» (всплытие, поднятие), потому что все объявления переменных var «всплывают» в самый верх функции.
В браузере глобальные функции и переменные, объявленные с помощью var (не let/const!), становятся свойствами глобального объекта
Значение переменной, объявленной с помощью const, нельзя переназначить. Есть некоторое недопонимание этого понятия, поднобнее ниже в примерах
Область видимости var переменных ограничена функцией, если вы обратитесь к переменной до её объявления, то получите undefined. const и let ограничены блоком, а попытка обратится к переменной до её объявления, вернётся ошибкой ReferenceError. И наконец, разница между let и const в том, что в первом случае вы можете изменить значение переменной, а во втором нет.

https://learn.javascript.ru/var
https://learn.javascript.ru/global-object
https://medium.com/nuances-of-programming/%D0%B2-%D1%87%D1%91%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-var-let-%D0%B8-const-%D0%B2-javascript-3084bfe9f7a3
*/
// const - Константа
// const something = 'string';
// something = 'another' // переназнчить константу невозможно

// const arr = [1, 2, 3];
// arr[1] = 5 // мы можем изменить значение под индесом 1 в массиве
// delete arr[0] // даже удалять
// arr.length = 0 // или даже так
// arr = []; но мы НЕ можем сделать так
// log(arr);

// const obj = {
//   name: 'Ivan'
// };
// obj.name = 'Max' // мы можем изменить свойство
// obj.surname = 'Master' // добавлять свойства
// obj.showFullName = function() {
//   return `Меня зовут ${this.name} ${this.surname}` // даже добавлять ии вызывать методы
// }
// log(obj)
// log(obj.showFullName())
// obj = 'another obj' // но не можем изменять значение константы

// var всплывает, let нет
// function hoisting() {
//   // log(variable) // var всплыло но пока не было передано значение
//   // variable = 'something'
//   // var variable;

//   // log(variable) // Ощибка инициализации
//   // variable = 'something'
//   // let variable;
// }
// hoisting()

// var всплывает, у него нет блочной области видимости, только глобальная и функциональная
// function one() {
//   log(digit) // var всплывает, переменная объявлена, но не имеет значения (und)
//   digit = 50; // присваиваем значение var
//   var digit;
//   function two() {
//     var digit = 100; // тут следует понимать, из правила var - видимость в своей фциональной области видимости, она никак не влияет на функцию выше.
//   }
//   two() // не на что не влияет, digit со значением 100 будет локальным в фции two
//   return digit // 50 на выходе
// }
// log(one())

// курьезы var
// function sum() {
//   var a = 777;
//   var b = 888;
//   if (true) {
//     var a = 5; // у var нет блочной ОВ, поэтому a и b перезапишуться
//     var b = 10;
//   }
//   log(a + b);

//   var a = 777;
//   var b = 888;
//   if (true) {
//     let a = 5; // с объявлением через let все иначе, мы будем находится только в блоке if и не сможем перезаписать a и b
//     let b = 10;
//   }
//   log(a + b);
// }
// sum()

// function cycleFor() {
//   var arr = [1, 2, 3];
//   var lengthArr = arr.length;
//   for (var arr = 0; arr < lengthArr; arr++) {
//     // something
//   }
//   // мы создали цикл для условного взаимодействия с массивом, но проблема в том что for - это тоже блочная ОВ, по сути мы просто перезаписали значение переменной arr на 0 и вернули итог выполнения задачи
//   log(arr);

//   var arr = [1, 2, 3];
//   var lengthArr = arr.length;
//   for (let arr = 0; arr < lengthArr; arr++) {
//     // something
//   }
//   // с let такой проблемы не будет, оно существует только в блоке ОВ цикла
//   log(arr);
// }
// cycleFor()

// function rewrite() {
//   // var digit = 500;
//   // if (digit >= 500) {
//   //   var digit = 100;
//   // }
//   // // здесь мы просто перезаписываем значение с помощью объявления var с таким же именем
//   // log(digit)

//   // let digit = 500;
//   // if (digit >= 500) {
//   //   let digit = 100;
//   // }
//   // // С let мы не сможем так сделать, 1 - будет ошибка, 2 - let уже имеет разные ОВ
//   // log(digit)

//   // let digit = 500;
//   // if (digit >= 500) {
//   //   digit = 100;
//   // }
//   // // мы можем изменить значение с помощью цепи областей видимости(Scope Chain), то есть мы просто ищем задекларированное имя digit по чепочке ОВ чтобы его перезаписать
//   // log(digit)
// }
// rewrite()